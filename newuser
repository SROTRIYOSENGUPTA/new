public class newuser {
    private String username;
    private String password;

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }
}

Connection to H2 database successful.
org.h2.jdbc.JdbcSQLException: Table "USERS" not found; SQL statement:

import java.io.BufferedReader;
import java.io.FileReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class UserDataWriteH2 {
    private static final String DATABASE_URL = "jdbc:h2:~/test";
    private static final String DATABASE_USER = "sa";
    private static final String DATABASE_PASSWORD = "";

    public static void main(String[] args) {
        // Create the table if it doesn't exist
        createTable();

        // Now you can proceed with inserting user data into the 'USERS' table
        // Prompt user for input (username and password) and create the User object...
    }

    private static void createTable() {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            String createTableScript = readFile("create_table.sql");

            try (Statement statement = connection.createStatement()) {
                statement.execute(createTableScript);
            }

            System.out.println("Table 'USERS' created successfully.");
        } catch (SQLException e) {
            System.err.println("Table creation failed: " + e.getMessage());
        }
    }

    private static String readFile(String filename) {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return content.toString();
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadH2 {
    private static final String DATABASE_URL = "jdbc:h2:~/test";
    private static final String DATABASE_USER = "sa";
    private static final String DATABASE_PASSWORD = "";

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            System.out.println("Connection to H2 database successful.");
        } catch (SQLException e) {
            System.err.println("Connection failed: " + e.getMessage());
        }

        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter username to search: ");
        String searchUsername = scanner.nextLine();
        scanner.close();

        // Search for the user based on the username input by the user
        User foundUser = searchForUser(searchUsername);

        // Display the result
        if (foundUser != null) {
            System.out.println("User found: " + foundUser.getName());
            System.out.println("Password for username '" + searchUsername + "' is: " + foundUser.getPassword());
        } else {
            System.out.println("Username not found.");
        }
    }

    private static User searchForUser(String searchUsername) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            String selectQuery = "SELECT name, password FROM users WHERE username = ?";

            try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
                statement.setString(1, searchUsername);

                try (ResultSet resultSet = statement.executeQuery()) {
                    if (resultSet.next()) {
                        String name = resultSet.getString("name");
                        String password = resultSet.getString("password");
                        return new User(name, searchUsername, password);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null; // Username not found
    }
}
java.io.FileNotFoundException: create_table.sql (The system cannot find the file specified)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:112)
	at java.base/java.io.FileReader.<init>(FileReader.java:60)
	at userdatawriteeeh2.readFile(userdatawriteeeh2.java:39)
	at userdatawriteeeh2.createTable(userdatawriteeeh2.java:25)
	at userdatawriteeeh2.main(userdatawriteeeh2.java:17)
Table 'USERS' created successfully.

cd C:\Users\YourUsername\ProjectFolder
cd: C:\Users\SSengupta\eclipse-workspace

javac UserDataWriteH2.java User.java UserDataReadH2.java

java UserDataWriteH2

java UserDataReadH2

Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	Duplicate local variable selectQuery

	at UserDataReadH2.searchForPassword(UserDataReadH2.java:63)
	at UserDataReadH2.main(UserDataReadH2.java:43)

private static String searchForPassword(String searchUsername) {
    try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
        String selectQuery = "SELECT password FROM users WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    return resultSet.getString("password");
                }
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null; // Username not found
}

Connection failed: No suitable driver found for jdbc:sqlite:my_database.db

Connection to SQLite database successful.
Enter username to search: user1
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: users)
Username not found.
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:54)
	at userdatareadlite.main(userdatareadlite.java:34)

////////////////////////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL
    // No need for separate username and password for SQLite, as it doesn't use authentication like H2

    public static void main(String[] args) {

        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {

            System.out.println("Connection to SQLite database successful.");

        } catch (SQLException e) {

            System.err.println("Connection failed: " + e.getMessage());

        }

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter username to search: ");

        String searchUsername = scanner.nextLine();

        scanner.close();

        // Search for the password based on the username input by the user
        String foundPassword = searchForPassword(searchUsername);

        // Display the result
        if (foundPassword != null) {

            System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);

        } else {

            System.out.println("Username not found.");

        }
    }

    private static String searchForPassword(String searchUsername) {

        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {

            String selectQuery = "SELECT password FROM t1 WHERE username = ?";

            try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {

                statement.setString(1, searchUsername);


                try (ResultSet resultSet = statement.executeQuery()) {
                    if (resultSet.next()) {
                        return resultSet.getString("password");
                    }
                }
            }
        } catch (SQLException e) {

            e.printStackTrace();
        }
        return null; // this will return this if the username is not found
    }
}

////

Connection to SQLite database successful.
Enter username to search: user1
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: t1)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:54)
	at userdatareadlite.main(userdatareadlite.java:34)
Username not found.
//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            // Search for the password based on the username input by the user
            String foundPassword = searchForPassword(connection, searchUsername);

            // Display the result
            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM t1 WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }
}
//
Connection to SQLite database successful.
Enter username to search: usera
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: t1)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:42)
	at userdatareadlite.main(userdatareadlite.java:25)
Username not found.

////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:C://my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            // Search for a specific username
            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            String foundPassword = searchForPassword(connection, searchUsername);

            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }

            // Retrieve and display all usernames and passwords from the t1 table
            System.out.println("\nAll usernames and passwords in the table t1:");
            getAllUsersAndPasswords(connection);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM t1 WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }

    private static void getAllUsersAndPasswords(Connection connection) {
        String selectAllQuery = "SELECT username, password FROM t1";

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                System.out.println("Username: " + username + ", Password: " + password);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//////

Microsoft Windows [Version 10.0.19045.3208]
(c) Microsoft Corporation. All rights reserved.

C:\Users\SSengupta>sqlite3 data.db
'sqlite3' is not recognized as an internal or external command,
operable program or batch file.

C:\Users\SSengupta>sqlite --version
'sqlite' is not recognized as an internal or external command,
operable program or batch file.

C:\Users\SSengupta>CD ..

C:\Users>cd ..

C:\>cd sqlite

C:\sqlite>ls -ltr
'ls' is not recognized as an internal or external command,
operable program or batch file.

C:\sqlite>pwd
'pwd' is not recognized as an internal or external command,
operable program or batch file.

C:\sqlite>dir
 Volume in drive C is Windows
 Volume Serial Number is D222-5DD7

 Directory of C:\sqlite

07/27/2023  02:55 PM    <DIR>          .
07/27/2023  02:55 PM    <DIR>          ..
07/27/2023  02:55 PM                 0 my_database.db
05/16/2023  09:46 AM           594,944 sqldiff.exe
05/16/2023  09:46 AM         1,153,024 sqlite3.exe
05/16/2023  09:46 AM         2,110,976 sqlite3_analyzer.exe
               4 File(s)      3,858,944 bytes
               2 Dir(s)  84,729,094,144 bytes free

C:\sqlite>sqlite3
SQLite version 3.42.0 2023-05-16 12:36:15
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> sqlite3 my_database.db
   ...> ;
Parse error: near "sqlite3": syntax error
  sqlite3 my_database.db ;
  ^--- error here
sqlite> sqlite3 my_database.db
   ...>
   ...> select * from user
   ...> select * from user;
Parse error: near "sqlite3": syntax error
  sqlite3 my_database.db  select * from user select * from user;
  ^--- error here
sqlite> .open my_database.db
sqlite> select * from users
   ...> ;
Parse error: no such table: users
sqlite> create table t1(one text, two int);
sqlite> select * from t1;
sqlite> insert into t1 values ('h', 1);
sqlite> select * from t1;
h|1
sqlite> drop table t1;
sqlite> select * from t1;
Parse error: no such table: t1
sqlite> insert into t1 values ('usera', 123);
Parse error: no such table: t1
sqlite> create table t1(one text, two int);
sqlite> insert into t1 values ('h', 1);
sqlite> insert into t1 values ('usera', 123);
sqlite> insert into t1 values ('userb', 112);
sqlite> select * from t1;
h|1
usera|123
userb|112
sqlite> drop table t1;
sqlite> create table t1(one text, two int);
sqlite> insert into t1 values ('user1', 1234);
sqlite> insert into t1 values ('user2', 2468);
sqlite> insert into t1 values ('user3', 1357);
sqlite> insert into t1 values ('user4', 3579);
sqlite> insert into t1 values ('user5', 9876);
sqlite> insert into t1 values ('user6', 8531);
sqlite> drop table t1
   ...> drop table t1;
Parse error: near "drop": syntax error
  drop table t1 drop table t1;
                ^--- error here
sqlite> drop table t1;
sqlite> create table userinput(user char, password char);
sqlite> insert into t1 values ('user1', 'password');
Parse error: no such table: t1
sqlite> insert into userinput values ('user1', 'password');
sqlite> insert into userinput values ('user2', 'password2');
sqlite> insert into userinput values ('user3', 'password3');
sqlite> insert into userinput values ('user4', 'password4');
sqlite> insert into userinput values ('user5', 'password5');
sqlite> select * from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
sqlite> select * from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
das;dj|saldikjasl;d
sqlite> select user, password from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
das;dj|saldikjasl;d
user6|password6
sqlite> select user, password from userinput;

// To do: print unlimited columns and generate unlimited tables like usertable

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataWriteLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            List<String> columnNames = new ArrayList<>();
            String columnName;
            do {
                System.out.print("Enter column name (or type 'done' to finish): ");
                columnName = scanner.nextLine();
                if (!columnName.equalsIgnoreCase("done")) {
                    columnNames.add(columnName);
                }
            } while (!columnName.equalsIgnoreCase("done"));

            if (columnNames.isEmpty()) {
                System.out.println("No columns specified. Exiting program.");
                return;
            }

            createTable(connection, tableName, columnNames);
            insertDataIntoTable(connection, tableName, columnNames);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void createTable(Connection connection, String tableName, List<String> columnNames) {
        StringBuilder createQuery = new StringBuilder("CREATE TABLE " + tableName + " (");

        for (int i = 0; i < columnNames.size(); i++) {
            createQuery.append(columnNames.get(i)).append(" TEXT");
            if (i < columnNames.size() - 1) {
                createQuery.append(", ");
            }
        }

        createQuery.append(");");

        try (PreparedStatement statement = connection.prepareStatement(createQuery.toString())) {
            statement.executeUpdate();
            System.out.println("Table '" + tableName + "' created successfully.");
        } catch (SQLException e) {
            System.err.println("Error creating table: " + e.getMessage());
        }
    }

    private static void insertDataIntoTable(Connection connection, String tableName, List<String> columnNames) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter data for each column:");
        StringBuilder insertQuery = new StringBuilder("INSERT INTO " + tableName + " (");
        for (int i = 0; i < columnNames.size(); i++) {
            insertQuery.append(columnNames.get(i));
            if (i < columnNames.size() - 1) {
                insertQuery.append(", ");
            }
        }
        insertQuery.append(") VALUES (");

        List<String> values = new ArrayList<>();
        for (String columnName : columnNames) {
            System.out.print(columnName + ": ");
            String value = scanner.nextLine();
            values.add(value);
            insertQuery.append("?, ");
        }
        insertQuery.delete(insertQuery.length() - 2, insertQuery.length()); // Remove the last comma and space
        insertQuery.append(");");

        try (PreparedStatement statement = connection.prepareStatement(insertQuery.toString())) {
            for (int i = 0; i < values.size(); i++) {
                statement.setString(i + 1, values.get(i));
            }

            statement.executeUpdate();
            System.out.println("Data inserted successfully into table '" + tableName + "'.");
        } catch (SQLException e) {
            System.err.println("Error inserting data: " + e.getMessage());
        }
    }
}

///

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            String foundPassword = searchForPassword(connection, tableName, searchUsername);

            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }

            // Retrieve and display all usernames and passwords from the custom table
            System.out.println("\nAll usernames and passwords in the table '" + tableName + "':");
            getAllUsersAndPasswords(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String tableName, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM " + tableName + " WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }

    private static void getAllUsersAndPasswords(Connection connection, String tableName) {
        String selectAllQuery = "SELECT username, password FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                System.out.println("Username: " + username + ", Password: " + password);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
///

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Replace these column names with the actual column names in your custom table
                String column1Value = resultSet.getString("column1");
                String column2Value = resultSet.getString("column2");
                // Add more columns if needed

                // Display the retrieved data
                System.out.println("Column 1: " + column1Value + ", Column 2: " + column2Value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            // Retrieve column names to display data dynamically
            List<String> columnNames = getColumnNames(resultSet);
            while (resultSet.next()) {
                // Display data for each row dynamically using column names
                for (String columnName : columnNames) {
                    String columnValue = resultSet.getString(columnName);
                    System.out.println(columnName + ": " + columnValue);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static List<String> getColumnNames(ResultSet resultSet) throws SQLException {
        List<String> columnNames = new ArrayList<>();
        int columnCount = resultSet.getMetaData().getColumnCount();
        for (int i = 1; i <= columnCount; i++) {
            columnNames.add(resultSet.getMetaData().getColumnName(i));
        }
        return columnNames;
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter columns (comma-separated) to select from the table: ");
            String columnsInput = scanner.nextLine();

            List<String> selectedColumns = parseColumnsInput(columnsInput);

            // Retrieve and display selected data from the custom table
            System.out.println("\nSelected data from the table '" + tableName + "':");
            getDataFromTable(connection, tableName, selectedColumns);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static List<String> parseColumnsInput(String input) {
        List<String> columns = new ArrayList<>();
        String[] columnArray = input.split(",");
        for (String column : columnArray) {
            columns.add(column.trim());
        }
        return columns;
    }

    private static void getDataFromTable(Connection connection, String tableName, List<String> selectedColumns) {
        String selectQuery = buildSelectQuery(tableName, selectedColumns);

        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Display data for each row
                for (String column : selectedColumns) {
                    String columnValue = resultSet.getString(column);
                    System.out.println(column + ": " + columnValue);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static String buildSelectQuery(String tableName, List<String> selectedColumns) {
        StringBuilder queryBuilder = new StringBuilder("SELECT ");
        for (int i = 0; i < selectedColumns.size(); i++) {
            queryBuilder.append(selectedColumns.get(i));
            if (i < selectedColumns.size() - 1) {
                queryBuilder.append(", ");
            }
        }
        queryBuilder.append(" FROM ").append(tableName);
        return queryBuilder.toString();
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();
            System.out.print("Enter value to search in '" + searchColumn + "': ");
            String searchValue = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "':");
            searchDataInTable(connection, tableName, searchColumn, searchValue);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn, String searchValue) {
        String selectQuery = "SELECT * FROM " + tableName + " WHERE " + searchColumn + " = ?";
        executeAndDisplayQueryWithParameter(connection, selectQuery, searchValue);
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Retrieve column names and display data for each row
                String columns = "";
                for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                    String column = resultSet.getMetaData().getColumnName(i);
                    String value = resultSet.getString(i);
                    System.out.println(column + ": " + value);
                    if (i != resultSet.getMetaData().getColumnCount()) {
                        columns += column + ", ";
                    } else {
                        columns += column;
                    }
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQueryWithParameter(Connection connection, String query, String parameter) {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, parameter);

            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    // Retrieve column names and display data for each row
                    String columns = "";
                    for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                        String column = resultSet.getMetaData().getColumnName(i);
                        String value = resultSet.getString(i);
                        System.out.println(column + ": " + value);
                        if (i != resultSet.getMetaData().getColumnCount()) {
                            columns += column + ", ";
                        } else {
                            columns += column;
                        }
                    }
                    System.out.println();
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:C://sqlite/my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();
           // System.out.print("Enter value to search in '" + searchColumn + "': ");
           //String searchValue = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "':");
            String searchValue = null;
            searchDataInTable(connection, tableName, searchColumn, searchValue);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn, String searchValue) {
        String selectQuery = "SELECT * FROM " + tableName + " WHERE " + searchColumn + " = ?";
        executeAndDisplayQueryWithParameter(connection, selectQuery, searchValue);
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Retrieve column names and display data for each row
                String columns = "";
                for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                    String column = resultSet.getMetaData().getColumnName(i);
                    String value = resultSet.getString(i);
                    System.out.println(column + ": " + value);
                    if (i != resultSet.getMetaData().getColumnCount()) {
                        columns += column + ", ";
                    } else {
                        columns += column;
                    }
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQueryWithParameter(Connection connection, String query, String parameter) {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, parameter);

            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    // Retrieve column names and display data for each row
                    String columns = "";
                    for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                        String column = resultSet.getMetaData().getColumnName(i);
                        String value = resultSet.getString(i);
                        System.out.println(column + ": " + value);
                        if (i != resultSet.getMetaData().getColumnCount()) {
                            columns += column + ", ";
                        } else {
                            columns += column;
                        }
                    }
                    System.out.println();
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
// this is the end of userdatareadlite

///

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "' for column '" + searchColumn + "':");
            searchDataInTable(connection, tableName, searchColumn);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn) {
        String selectQuery = "SELECT * FROM " + tableName;
        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String value = resultSet.getString(searchColumn);
                System.out.println(value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            // Retrieve column names
            DatabaseMetaData metaData = connection.getMetaData();
            ResultSet columnsResultSet = metaData.getColumns(null, null, resultSet.getMetaData().getTableName(1), null);

            String columns = "";
            while (columnsResultSet.next()) {
                columns += columnsResultSet.getString("COLUMN_NAME") + ", ";
            }
            columns = columns.substring(0, columns.length() - 2);

            // Display data for each row
            while (resultSet.next()) {
                System.out.println("Row " + resultSet.getRow() + ":");
                for (String column : columns.split(", ")) {
                    String value = resultSet.getString(column);
                    System.out.println(column + ": " + value);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter column name to search (or type 'stop' to finish): ");
            String searchColumn = scanner.nextLine();

            while (!searchColumn.equalsIgnoreCase("stop")) {
                // Retrieve and display search results
                System.out.println("\nSearch results in the table '" + tableName + "' for column '" + searchColumn + "':");
                searchDataInTable(connection, tableName, searchColumn);

                System.out.print("\nEnter column name to search (or type 'stop' to finish): ");
                searchColumn = scanner.nextLine();
            }
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn) {
        String selectQuery = "SELECT " + searchColumn + " FROM " + tableName;
        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String value = resultSet.getString(1);
                System.out.println(value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            List<String> columnsToSearch = new ArrayList<>();
            String column;
            do {
                System.out.print("Enter column name(s) to search (comma-separated, or type 'stop' to finish): ");
                column = scanner.nextLine().trim();
                if (!column.equalsIgnoreCase("stop") && !column.isEmpty()) {
                    columnsToSearch.addAll(Arrays.asList(column.split("\\s*,\\s*")));
                }
            } while (!column.equalsIgnoreCase("stop"));

            if (columnsToSearch.isEmpty()) {
                System.out.println("No columns specified. Exiting program.");
                return;
            }

            System.out.println("\nSearch results in the table '" + tableName + "':");
            searchDataInTable(connection, tableName, columnsToSearch);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void searchDataInTable(Connection connection, String tableName, List<String> columnsToSearch) {
        StringBuilder selectQuery = new StringBuilder("SELECT ");
        for (int i = 0; i < columnsToSearch.size(); i++) {
            selectQuery.append(columnsToSearch.get(i));
            if (i < columnsToSearch.size() - 1) {
                selectQuery.append(", ");
            }
        }
        selectQuery.append(" FROM ").append(tableName);

        try (PreparedStatement statement = connection.prepareStatement(selectQuery.toString());
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                for (String column : columnsToSearch) {
                    String value = resultSet.getString(column);
                    System.out.println(column + ": " + value);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}




import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SqlSearch {
    // Assuming SMeta and SbfMeta are classes defining tsearch and tsearchcol columns

    public PreparedStatement getNewSearchStatement(Connection con, int searchId) throws SQLException {
        String tsearchTableName = "tsearch"; // Replace with the actual table name
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public PreparedStatement getNewSearchColStatement(Connection con, int searchId) throws SQLException {
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchcolTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        try {
            // Replace with your database connection logic
            Connection connection = getConnection();

            SqlSearch sqlSearch = new SqlSearch();
            int searchId = 123; // Replace with the actual search ID

            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId);
            ResultSet searchResultSet = searchStatement.executeQuery();
            // Process searchResultSet as needed

            PreparedStatement searchColStatement = sqlSearch.getNewSearchColStatement(connection, searchId);
            ResultSet searchColResultSet = searchColStatement.executeQuery();
            // Process searchColResultSet as needed

            // Close the resources appropriately
            searchResultSet.close();
            searchStatement.close();
            searchColResultSet.close();
            searchColStatement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SqlSearch {

    // Replace with your actual database connection details
    private static final String DB_URL = "jdbc:mysql://localhost:3306/your_database";
    private static final String DB_USER = "your_username";
    private static final String DB_PASSWORD = "your_password";

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
    }

    public PreparedStatement getNewSearchStatement(Connection con, int searchId) throws SQLException {
        String tsearchTableName = "tsearch"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public PreparedStatement getNewSearchColStatement(Connection con, int searchId) throws SQLException {
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchcolTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        SqlSearch sqlSearch = new SqlSearch();
        int searchId = 123; // Replace with the actual search ID

        try (Connection connection = sqlSearch.getConnection()) {
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId);
            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }

            PreparedStatement searchColStatement = sqlSearch.getNewSearchColStatement(connection, searchId);
            try (ResultSet searchColResultSet = searchColStatement.executeQuery()) {
                while (searchColResultSet.next()) {
                    // Process each row in the searchColResultSet
                    // For example: String columnValue = searchColResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


///

public class SqlSearch {

    public PreparedStatement getNewSearchStatement(Connection con, int searchId, boolean useSbm) throws SQLException {
        if (useSbm) {
            String query = "SELECT * FROM t_search WHERE searchId = ?";
            PreparedStatement preparedStatement = con.prepareStatement(query);
            preparedStatement.setInt(1, searchId);
            return preparedStatement;
        } else {
            String query = "SELECT * FROM t_searchcol WHERE searchId = ?";
            PreparedStatement preparedStatement = con.prepareStatement(query);
            preparedStatement.setInt(1, searchId);
            return preparedStatement;
        }
    }

    public static void main(String[] args) {
        int searchId = 123; // Replace with the actual search ID
        boolean useSbm = true; // Change this based on your requirement

        try (Connection connection = getConnection()) {
            SqlSearch sqlSearch = new SqlSearch();
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId, useSbm);

            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

/////

public class SqlSearch {

    public PreparedStatement getNewSearchStatement(Connection con, int searchId, boolean useSbm) throws SQLException {
        String query;
        if (useSbm) {
            Sbm sbm = new Sbm();
            query = sbm.getSearchQuery(searchId);
        } else {
            Sbf sbf = new Sbf();
            query = sbf.getSearchColQuery(searchId);
        }

        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        int searchId = 123; // Replace with the actual search ID
        boolean useSbm = true; // Change this based on your requirement

        try (Connection connection = getConnection()) {
            SqlSearch sqlSearch = new SqlSearch();
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId, useSbm);

            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

public class YourClass {

    public static Properties getSSearchStatement(Connection conn, SBM sbmObject, SBFM sbfmObject) throws Exception {
        int searchId = sbmObject.getSearchId();

        if (statementHash.get(searchId + "") != null) {
            return ((Properties) statementHash.get(searchId + ""));
        }

        Properties props = new Properties();

        try {
            // Extract information from sbmObject and sbfmObject
            String tables = sbmObject.getTables();
            List<String> conditions = new ArrayList<>();
            
            String standardCondition = sbmObject.getStandardCondition();
            if (standardCondition != null && !standardCondition.isEmpty()) {
                conditions.add(standardCondition);
            }

            String groupByCondition = sbfmObject.getGroupByCondition();
            if (groupByCondition != null && !groupByCondition.isEmpty()) {
                conditions.add(" group by " + groupByCondition);
            }

            String havingCondition = sbfmObject.getHavingCondition();
            if (havingCondition != null && !havingCondition.isEmpty()) {
                conditions.add(" having " + havingCondition);
            }

            int recCount = sbmObject.getRecordsPerPage();

            // Populate properties based on extracted information
            props.put(SQLSearchStatement.TABLES, tables);

            if (!conditions.isEmpty()) {
                props.put(SQLSearchStatement.CONDITIONS, String.join("", conditions));
            }

            if (recCount > 0) {
                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);
            }

            String columns = sbfmObject.getColumnExpressionsWithAliases();

            if (!columns.isEmpty()) {
                props.put(SQLSearchStatement.COLUMNS, columns);
            } else {
                String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";
                log.error(msg);
                throw new Exception(msg);
            }

            statementHash.put(searchId + "", props);
        } catch (SQLException e) {
            log.error("SQL Exception occurred: " + e.getMessage());
            throw e;
        } finally {
            // Close resources, if needed
        }

        return props;

/////

public static Properties getnewSearchStatement(Connection conn, SBeanMeta s, SBeanFieldMeta t) throws Exception {

        int sid = s.getsid();

        if (statementHash.get(sid + "") != null) {

            return ((Properties) statementHash.get(sid + ""));

        }

        Properties props = new Properties();

        try {
            // Here we extracting information from s and t here

            String tables = s.gettables();

            List<String> conditions = new ArrayList<>();

            String scondition = s.getscondition();

            if (scondition != null && !scondition.isEmpty()) {

                conditions.add("standard_condition_column" );

            }

            String gcondition = s.getgcondition();

            if (gcondition!= null && !gcondition.isEmpty()) {

                conditions.add("group_by_condition_column");
            }

            String hcondition = s.gethcondition();

            if (hcondition != null && !hcondition.isEmpty()) {

                conditions.add(" having_condition_column > 1000 ");

            }


            int rppage = s.getrppage();


            props.put(SQLSearchStatement.TABLES, tables);

            /*
              // hcondition == false
             if (!conditions.isEmpty()) {

                props.put(SQLSearchStatement.CONDITIONS, String.join("", conditions));
            }*/


            //if (recCount > 0) {
               // props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);
         //   }

            String fieldName = t.getfieldName();

            String expression = t.getExpression();

            if (!fieldName.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, fieldName);

            }

            if (!expression.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, expression);

            }

            else
            {

                String text = "Search id" + sid + " is not set up in T_SEARCHCOL";

                log.error(text);

                throw new Exception(text);
            }

            statementHash.put(sid + "", props);

        }

        catch (SQLException z) {

            log.error("SQL Exception occurred: " + z.getMessage());

            throw z;

        }

        return props;
    }

// old

public static Properties getSearchStatement(Connection conn, int searchId) throws SQLException, Exception
    {



        if(statementHash.get(searchId+"") != null)

        {

            return ((Properties)statementHash.get(searchId+""));

        }

        Properties props = new Properties();

        Statement stmt = conn.createStatement();

        // get main statement
        String sql = "select Tables, Standard_Condition, Group_By_Condition, Having_Condition , Records_Per_Page from t_Search where search_id = " + searchId;

        // this sql method is getting tables, standard_condition, group_by_condition, having_condition, records_per_page as output and getting them from t_search with a specific search_id


        ResultSet rs = stmt.executeQuery(sql);

        if (rs.next())

        {
            String tables = rs.getString(1);

            String standardCondition = rs.getString(2);

            String groupByCondition = rs.getString(3);

            String havingCondition = rs.getString(4);

            props.put(SQLSearchStatement.TABLES, tables);

            if (standardCondition != null && !standardCondition.equals(""))
            {
                props.put(SQLSearchStatement.STANDARD_CONDITION, standardCondition);
            }
            if (groupByCondition != null && !groupByCondition.equals(""))

            {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, " group by " + groupByCondition);

            }
            if (havingCondition != null && !havingCondition.equals("")) {

                props.put(SQLSearchStatement.HAVING_CONDITION, " having " + havingCondition);

            }

            int recCount = rs.getInt(5);

            if(recCount > 0) {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT,new Integer(recCount));
            }
        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCH";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);
        }

        rs.close();


        // get columns
        sql = "select Col_Expression, Col_Alias from t_SearchCol where search_id = " + searchId + " order by col_id";

        rs = stmt.executeQuery(sql);

        StringBuffer sb = new StringBuffer();

        while (rs.next()) {

            if (sb.length() > 1) {

                sb.append(", ");

            }

            sb.append(rs.getString(1));

            if (rs.getString(2) != null && !rs.getString(1).equalsIgnoreCase(rs.getString(2))) {

                sb.append(" as ");

                sb.append(rs.getString(2));

            }
        }

        rs.close();

        if (sb.length() > 1) {

            props.put(SQLSearchStatement.COLUMNS, sb.toString());

        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);

        }

        stmt.close();

        statementHash.put(searchId+"" , props);

        return props;
    }


