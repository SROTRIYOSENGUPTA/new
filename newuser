public class newuser {
    private String username;
    private String password;

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }
}

Connection to H2 database successful.
org.h2.jdbc.JdbcSQLException: Table "USERS" not found; SQL statement:

import java.io.BufferedReader;
import java.io.FileReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class UserDataWriteH2 {
    private static final String DATABASE_URL = "jdbc:h2:~/test";
    private static final String DATABASE_USER = "sa";
    private static final String DATABASE_PASSWORD = "";

    public static void main(String[] args) {
        // Create the table if it doesn't exist
        createTable();

        // Now you can proceed with inserting user data into the 'USERS' table
        // Prompt user for input (username and password) and create the User object...
    }

    private static void createTable() {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            String createTableScript = readFile("create_table.sql");

            try (Statement statement = connection.createStatement()) {
                statement.execute(createTableScript);
            }

            System.out.println("Table 'USERS' created successfully.");
        } catch (SQLException e) {
            System.err.println("Table creation failed: " + e.getMessage());
        }
    }

    private static String readFile(String filename) {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return content.toString();
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadH2 {
    private static final String DATABASE_URL = "jdbc:h2:~/test";
    private static final String DATABASE_USER = "sa";
    private static final String DATABASE_PASSWORD = "";

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            System.out.println("Connection to H2 database successful.");
        } catch (SQLException e) {
            System.err.println("Connection failed: " + e.getMessage());
        }

        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter username to search: ");
        String searchUsername = scanner.nextLine();
        scanner.close();

        // Search for the user based on the username input by the user
        User foundUser = searchForUser(searchUsername);

        // Display the result
        if (foundUser != null) {
            System.out.println("User found: " + foundUser.getName());
            System.out.println("Password for username '" + searchUsername + "' is: " + foundUser.getPassword());
        } else {
            System.out.println("Username not found.");
        }
    }

    private static User searchForUser(String searchUsername) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
            String selectQuery = "SELECT name, password FROM users WHERE username = ?";

            try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
                statement.setString(1, searchUsername);

                try (ResultSet resultSet = statement.executeQuery()) {
                    if (resultSet.next()) {
                        String name = resultSet.getString("name");
                        String password = resultSet.getString("password");
                        return new User(name, searchUsername, password);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null; // Username not found
    }
}
java.io.FileNotFoundException: create_table.sql (The system cannot find the file specified)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:112)
	at java.base/java.io.FileReader.<init>(FileReader.java:60)
	at userdatawriteeeh2.readFile(userdatawriteeeh2.java:39)
	at userdatawriteeeh2.createTable(userdatawriteeeh2.java:25)
	at userdatawriteeeh2.main(userdatawriteeeh2.java:17)
Table 'USERS' created successfully.

cd C:\Users\YourUsername\ProjectFolder
cd: C:\Users\SSengupta\eclipse-workspace

javac UserDataWriteH2.java User.java UserDataReadH2.java

java UserDataWriteH2

java UserDataReadH2

Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	Duplicate local variable selectQuery

	at UserDataReadH2.searchForPassword(UserDataReadH2.java:63)
	at UserDataReadH2.main(UserDataReadH2.java:43)

private static String searchForPassword(String searchUsername) {
    try (Connection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD)) {
        String selectQuery = "SELECT password FROM users WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    return resultSet.getString("password");
                }
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null; // Username not found
}

Connection failed: No suitable driver found for jdbc:sqlite:my_database.db

Connection to SQLite database successful.
Enter username to search: user1
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: users)
Username not found.
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:54)
	at userdatareadlite.main(userdatareadlite.java:34)

////////////////////////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL
    // No need for separate username and password for SQLite, as it doesn't use authentication like H2

    public static void main(String[] args) {

        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {

            System.out.println("Connection to SQLite database successful.");

        } catch (SQLException e) {

            System.err.println("Connection failed: " + e.getMessage());

        }

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter username to search: ");

        String searchUsername = scanner.nextLine();

        scanner.close();

        // Search for the password based on the username input by the user
        String foundPassword = searchForPassword(searchUsername);

        // Display the result
        if (foundPassword != null) {

            System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);

        } else {

            System.out.println("Username not found.");

        }
    }

    private static String searchForPassword(String searchUsername) {

        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {

            String selectQuery = "SELECT password FROM t1 WHERE username = ?";

            try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {

                statement.setString(1, searchUsername);


                try (ResultSet resultSet = statement.executeQuery()) {
                    if (resultSet.next()) {
                        return resultSet.getString("password");
                    }
                }
            }
        } catch (SQLException e) {

            e.printStackTrace();
        }
        return null; // this will return this if the username is not found
    }
}

////

Connection to SQLite database successful.
Enter username to search: user1
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: t1)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:54)
	at userdatareadlite.main(userdatareadlite.java:34)
Username not found.
//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            // Search for the password based on the username input by the user
            String foundPassword = searchForPassword(connection, searchUsername);

            // Display the result
            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM t1 WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }
}
//
Connection to SQLite database successful.
Enter username to search: usera
org.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (no such table: t1)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1179)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.newSQLException(DB.java:1190)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.throwex(DB.java:1150)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare_utf8(Native Method)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.NativeDB.prepare(NativeDB.java:126)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.DB.prepare(DB.java:264)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.core.CorePreparedStatement.<init>(CorePreparedStatement.java:46)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3PreparedStatement.<init>(JDBC3PreparedStatement.java:32)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4PreparedStatement.<init>(JDBC4PreparedStatement.java:25)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc4.JDBC4Connection.prepareStatement(JDBC4Connection.java:34)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:226)
	at org.xerial.sqlitejdbc@3.42.0.0/org.sqlite.jdbc3.JDBC3Connection.prepareStatement(JDBC3Connection.java:206)
	at userdatareadlite.searchForPassword(userdatareadlite.java:42)
	at userdatareadlite.main(userdatareadlite.java:25)
Username not found.

////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:C://my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            // Search for a specific username
            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            String foundPassword = searchForPassword(connection, searchUsername);

            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }

            // Retrieve and display all usernames and passwords from the t1 table
            System.out.println("\nAll usernames and passwords in the table t1:");
            getAllUsersAndPasswords(connection);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM t1 WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }

    private static void getAllUsersAndPasswords(Connection connection) {
        String selectAllQuery = "SELECT username, password FROM t1";

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                System.out.println("Username: " + username + ", Password: " + password);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//////

Microsoft Windows [Version 10.0.19045.3208]
(c) Microsoft Corporation. All rights reserved.

C:\Users\SSengupta>sqlite3 data.db
'sqlite3' is not recognized as an internal or external command,
operable program or batch file.

C:\Users\SSengupta>sqlite --version
'sqlite' is not recognized as an internal or external command,
operable program or batch file.

C:\Users\SSengupta>CD ..

C:\Users>cd ..

C:\>cd sqlite

C:\sqlite>ls -ltr
'ls' is not recognized as an internal or external command,
operable program or batch file.

C:\sqlite>pwd
'pwd' is not recognized as an internal or external command,
operable program or batch file.

C:\sqlite>dir
 Volume in drive C is Windows
 Volume Serial Number is D222-5DD7

 Directory of C:\sqlite

07/27/2023  02:55 PM    <DIR>          .
07/27/2023  02:55 PM    <DIR>          ..
07/27/2023  02:55 PM                 0 my_database.db
05/16/2023  09:46 AM           594,944 sqldiff.exe
05/16/2023  09:46 AM         1,153,024 sqlite3.exe
05/16/2023  09:46 AM         2,110,976 sqlite3_analyzer.exe
               4 File(s)      3,858,944 bytes
               2 Dir(s)  84,729,094,144 bytes free

C:\sqlite>sqlite3
SQLite version 3.42.0 2023-05-16 12:36:15
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> sqlite3 my_database.db
   ...> ;
Parse error: near "sqlite3": syntax error
  sqlite3 my_database.db ;
  ^--- error here
sqlite> sqlite3 my_database.db
   ...>
   ...> select * from user
   ...> select * from user;
Parse error: near "sqlite3": syntax error
  sqlite3 my_database.db  select * from user select * from user;
  ^--- error here
sqlite> .open my_database.db
sqlite> select * from users
   ...> ;
Parse error: no such table: users
sqlite> create table t1(one text, two int);
sqlite> select * from t1;
sqlite> insert into t1 values ('h', 1);
sqlite> select * from t1;
h|1
sqlite> drop table t1;
sqlite> select * from t1;
Parse error: no such table: t1
sqlite> insert into t1 values ('usera', 123);
Parse error: no such table: t1
sqlite> create table t1(one text, two int);
sqlite> insert into t1 values ('h', 1);
sqlite> insert into t1 values ('usera', 123);
sqlite> insert into t1 values ('userb', 112);
sqlite> select * from t1;
h|1
usera|123
userb|112
sqlite> drop table t1;
sqlite> create table t1(one text, two int);
sqlite> insert into t1 values ('user1', 1234);
sqlite> insert into t1 values ('user2', 2468);
sqlite> insert into t1 values ('user3', 1357);
sqlite> insert into t1 values ('user4', 3579);
sqlite> insert into t1 values ('user5', 9876);
sqlite> insert into t1 values ('user6', 8531);
sqlite> drop table t1
   ...> drop table t1;
Parse error: near "drop": syntax error
  drop table t1 drop table t1;
                ^--- error here
sqlite> drop table t1;
sqlite> create table userinput(user char, password char);
sqlite> insert into t1 values ('user1', 'password');
Parse error: no such table: t1
sqlite> insert into userinput values ('user1', 'password');
sqlite> insert into userinput values ('user2', 'password2');
sqlite> insert into userinput values ('user3', 'password3');
sqlite> insert into userinput values ('user4', 'password4');
sqlite> insert into userinput values ('user5', 'password5');
sqlite> select * from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
sqlite> select * from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
das;dj|saldikjasl;d
sqlite> select user, password from userinput;
user1|password
user2|password2
user3|password3
user4|password4
user5|password5
das;dj|saldikjasl;d
user6|password6
sqlite> select user, password from userinput;

// To do: print unlimited columns and generate unlimited tables like usertable

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataWriteLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            List<String> columnNames = new ArrayList<>();
            String columnName;
            do {
                System.out.print("Enter column name (or type 'done' to finish): ");
                columnName = scanner.nextLine();
                if (!columnName.equalsIgnoreCase("done")) {
                    columnNames.add(columnName);
                }
            } while (!columnName.equalsIgnoreCase("done"));

            if (columnNames.isEmpty()) {
                System.out.println("No columns specified. Exiting program.");
                return;
            }

            createTable(connection, tableName, columnNames);
            insertDataIntoTable(connection, tableName, columnNames);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void createTable(Connection connection, String tableName, List<String> columnNames) {
        StringBuilder createQuery = new StringBuilder("CREATE TABLE " + tableName + " (");

        for (int i = 0; i < columnNames.size(); i++) {
            createQuery.append(columnNames.get(i)).append(" TEXT");
            if (i < columnNames.size() - 1) {
                createQuery.append(", ");
            }
        }

        createQuery.append(");");

        try (PreparedStatement statement = connection.prepareStatement(createQuery.toString())) {
            statement.executeUpdate();
            System.out.println("Table '" + tableName + "' created successfully.");
        } catch (SQLException e) {
            System.err.println("Error creating table: " + e.getMessage());
        }
    }

    private static void insertDataIntoTable(Connection connection, String tableName, List<String> columnNames) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter data for each column:");
        StringBuilder insertQuery = new StringBuilder("INSERT INTO " + tableName + " (");
        for (int i = 0; i < columnNames.size(); i++) {
            insertQuery.append(columnNames.get(i));
            if (i < columnNames.size() - 1) {
                insertQuery.append(", ");
            }
        }
        insertQuery.append(") VALUES (");

        List<String> values = new ArrayList<>();
        for (String columnName : columnNames) {
            System.out.print(columnName + ": ");
            String value = scanner.nextLine();
            values.add(value);
            insertQuery.append("?, ");
        }
        insertQuery.delete(insertQuery.length() - 2, insertQuery.length()); // Remove the last comma and space
        insertQuery.append(");");

        try (PreparedStatement statement = connection.prepareStatement(insertQuery.toString())) {
            for (int i = 0; i < values.size(); i++) {
                statement.setString(i + 1, values.get(i));
            }

            statement.executeUpdate();
            System.out.println("Data inserted successfully into table '" + tableName + "'.");
        } catch (SQLException e) {
            System.err.println("Error inserting data: " + e.getMessage());
        }
    }
}

///

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter username to search: ");
            String searchUsername = scanner.nextLine();

            String foundPassword = searchForPassword(connection, tableName, searchUsername);

            if (foundPassword != null) {
                System.out.println("Password for username '" + searchUsername + "' is: " + foundPassword);
            } else {
                System.out.println("Username not found.");
            }

            // Retrieve and display all usernames and passwords from the custom table
            System.out.println("\nAll usernames and passwords in the table '" + tableName + "':");
            getAllUsersAndPasswords(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static String searchForPassword(Connection connection, String tableName, String searchUsername) {
        String foundPassword = null;
        String selectQuery = "SELECT password FROM " + tableName + " WHERE username = ?";

        try (PreparedStatement statement = connection.prepareStatement(selectQuery)) {
            statement.setString(1, searchUsername);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    foundPassword = resultSet.getString("password");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return foundPassword; // Return null if the username is not found
    }

    private static void getAllUsersAndPasswords(Connection connection, String tableName) {
        String selectAllQuery = "SELECT username, password FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                System.out.println("Username: " + username + ", Password: " + password);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
///

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Replace these column names with the actual column names in your custom table
                String column1Value = resultSet.getString("column1");
                String column2Value = resultSet.getString("column2");
                // Add more columns if needed

                // Display the retrieved data
                System.out.println("Column 1: " + column1Value + ", Column 2: " + column2Value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;

        try (PreparedStatement statement = connection.prepareStatement(selectAllQuery);
             ResultSet resultSet = statement.executeQuery()) {

            // Retrieve column names to display data dynamically
            List<String> columnNames = getColumnNames(resultSet);
            while (resultSet.next()) {
                // Display data for each row dynamically using column names
                for (String columnName : columnNames) {
                    String columnValue = resultSet.getString(columnName);
                    System.out.println(columnName + ": " + columnValue);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static List<String> getColumnNames(ResultSet resultSet) throws SQLException {
        List<String> columnNames = new ArrayList<>();
        int columnCount = resultSet.getMetaData().getColumnCount();
        for (int i = 1; i <= columnCount; i++) {
            columnNames.add(resultSet.getMetaData().getColumnName(i));
        }
        return columnNames;
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter columns (comma-separated) to select from the table: ");
            String columnsInput = scanner.nextLine();

            List<String> selectedColumns = parseColumnsInput(columnsInput);

            // Retrieve and display selected data from the custom table
            System.out.println("\nSelected data from the table '" + tableName + "':");
            getDataFromTable(connection, tableName, selectedColumns);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static List<String> parseColumnsInput(String input) {
        List<String> columns = new ArrayList<>();
        String[] columnArray = input.split(",");
        for (String column : columnArray) {
            columns.add(column.trim());
        }
        return columns;
    }

    private static void getDataFromTable(Connection connection, String tableName, List<String> selectedColumns) {
        String selectQuery = buildSelectQuery(tableName, selectedColumns);

        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Display data for each row
                for (String column : selectedColumns) {
                    String columnValue = resultSet.getString(column);
                    System.out.println(column + ": " + columnValue);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static String buildSelectQuery(String tableName, List<String> selectedColumns) {
        StringBuilder queryBuilder = new StringBuilder("SELECT ");
        for (int i = 0; i < selectedColumns.size(); i++) {
            queryBuilder.append(selectedColumns.get(i));
            if (i < selectedColumns.size() - 1) {
                queryBuilder.append(", ");
            }
        }
        queryBuilder.append(" FROM ").append(tableName);
        return queryBuilder.toString();
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();
            System.out.print("Enter value to search in '" + searchColumn + "': ");
            String searchValue = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "':");
            searchDataInTable(connection, tableName, searchColumn, searchValue);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn, String searchValue) {
        String selectQuery = "SELECT * FROM " + tableName + " WHERE " + searchColumn + " = ?";
        executeAndDisplayQueryWithParameter(connection, selectQuery, searchValue);
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Retrieve column names and display data for each row
                String columns = "";
                for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                    String column = resultSet.getMetaData().getColumnName(i);
                    String value = resultSet.getString(i);
                    System.out.println(column + ": " + value);
                    if (i != resultSet.getMetaData().getColumnCount()) {
                        columns += column + ", ";
                    } else {
                        columns += column;
                    }
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQueryWithParameter(Connection connection, String query, String parameter) {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, parameter);

            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    // Retrieve column names and display data for each row
                    String columns = "";
                    for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                        String column = resultSet.getMetaData().getColumnName(i);
                        String value = resultSet.getString(i);
                        System.out.println(column + ": " + value);
                        if (i != resultSet.getMetaData().getColumnCount()) {
                            columns += column + ", ";
                        } else {
                            columns += column;
                        }
                    }
                    System.out.println();
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

////

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class userdatareadlite {
    private static final String DATABASE_URL = "jdbc:sqlite:C://sqlite/my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();
           // System.out.print("Enter value to search in '" + searchColumn + "': ");
           //String searchValue = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "':");
            String searchValue = null;
            searchDataInTable(connection, tableName, searchColumn, searchValue);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn, String searchValue) {
        String selectQuery = "SELECT * FROM " + tableName + " WHERE " + searchColumn + " = ?";
        executeAndDisplayQueryWithParameter(connection, selectQuery, searchValue);
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                // Retrieve column names and display data for each row
                String columns = "";
                for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                    String column = resultSet.getMetaData().getColumnName(i);
                    String value = resultSet.getString(i);
                    System.out.println(column + ": " + value);
                    if (i != resultSet.getMetaData().getColumnCount()) {
                        columns += column + ", ";
                    } else {
                        columns += column;
                    }
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQueryWithParameter(Connection connection, String query, String parameter) {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, parameter);

            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    // Retrieve column names and display data for each row
                    String columns = "";
                    for (int i = 1; i <= resultSet.getMetaData().getColumnCount(); i++) {
                        String column = resultSet.getMetaData().getColumnName(i);
                        String value = resultSet.getString(i);
                        System.out.println(column + ": " + value);
                        if (i != resultSet.getMetaData().getColumnCount()) {
                            columns += column + ", ";
                        } else {
                            columns += column;
                        }
                    }
                    System.out.println();
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
// this is the end of userdatareadlite

///

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            // Retrieve and display all data from the custom table
            System.out.println("\nAll data in the table '" + tableName + "':");
            getAllDataFromTable(connection, tableName);

            System.out.print("\nEnter column name to search: ");
            String searchColumn = scanner.nextLine();

            // Retrieve and display search results
            System.out.println("\nSearch results in the table '" + tableName + "' for column '" + searchColumn + "':");
            searchDataInTable(connection, tableName, searchColumn);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void getAllDataFromTable(Connection connection, String tableName) {
        String selectAllQuery = "SELECT * FROM " + tableName;
        executeAndDisplayQuery(connection, selectAllQuery);
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn) {
        String selectQuery = "SELECT * FROM " + tableName;
        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String value = resultSet.getString(searchColumn);
                System.out.println(value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void executeAndDisplayQuery(Connection connection, String query) {
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            // Retrieve column names
            DatabaseMetaData metaData = connection.getMetaData();
            ResultSet columnsResultSet = metaData.getColumns(null, null, resultSet.getMetaData().getTableName(1), null);

            String columns = "";
            while (columnsResultSet.next()) {
                columns += columnsResultSet.getString("COLUMN_NAME") + ", ";
            }
            columns = columns.substring(0, columns.length() - 2);

            // Display data for each row
            while (resultSet.next()) {
                System.out.println("Row " + resultSet.getRow() + ":");
                for (String column : columns.split(", ")) {
                    String value = resultSet.getString(column);
                    System.out.println(column + ": " + value);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            System.out.print("Enter column name to search (or type 'stop' to finish): ");
            String searchColumn = scanner.nextLine();

            while (!searchColumn.equalsIgnoreCase("stop")) {
                // Retrieve and display search results
                System.out.println("\nSearch results in the table '" + tableName + "' for column '" + searchColumn + "':");
                searchDataInTable(connection, tableName, searchColumn);

                System.out.print("\nEnter column name to search (or type 'stop' to finish): ");
                searchColumn = scanner.nextLine();
            }
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void searchDataInTable(Connection connection, String tableName, String searchColumn) {
        String selectQuery = "SELECT " + searchColumn + " FROM " + tableName;
        try (PreparedStatement statement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String value = resultSet.getString(1);
                System.out.println(value);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

public class UserDataReadLite {
    private static final String DATABASE_URL = "jdbc:sqlite:my_database.db"; // SQLite connection URL

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(DATABASE_URL)) {
            System.out.println("Connection to SQLite database successful.");

            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter table name: ");
            String tableName = scanner.nextLine();

            List<String> columnsToSearch = new ArrayList<>();
            String column;
            do {
                System.out.print("Enter column name(s) to search (comma-separated, or type 'stop' to finish): ");
                column = scanner.nextLine().trim();
                if (!column.equalsIgnoreCase("stop") && !column.isEmpty()) {
                    columnsToSearch.addAll(Arrays.asList(column.split("\\s*,\\s*")));
                }
            } while (!column.equalsIgnoreCase("stop"));

            if (columnsToSearch.isEmpty()) {
                System.out.println("No columns specified. Exiting program.");
                return;
            }

            System.out.println("\nSearch results in the table '" + tableName + "':");
            searchDataInTable(connection, tableName, columnsToSearch);
        } catch (SQLException e) {
            System.err.println("Connection failed or SQL error: " + e.getMessage());
        }
    }

    private static void searchDataInTable(Connection connection, String tableName, List<String> columnsToSearch) {
        StringBuilder selectQuery = new StringBuilder("SELECT ");
        for (int i = 0; i < columnsToSearch.size(); i++) {
            selectQuery.append(columnsToSearch.get(i));
            if (i < columnsToSearch.size() - 1) {
                selectQuery.append(", ");
            }
        }
        selectQuery.append(" FROM ").append(tableName);

        try (PreparedStatement statement = connection.prepareStatement(selectQuery.toString());
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                for (String column : columnsToSearch) {
                    String value = resultSet.getString(column);
                    System.out.println(column + ": " + value);
                }
                System.out.println();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}




import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SqlSearch {
    // Assuming SMeta and SbfMeta are classes defining tsearch and tsearchcol columns

    public PreparedStatement getNewSearchStatement(Connection con, int searchId) throws SQLException {
        String tsearchTableName = "tsearch"; // Replace with the actual table name
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public PreparedStatement getNewSearchColStatement(Connection con, int searchId) throws SQLException {
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchcolTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        try {
            // Replace with your database connection logic
            Connection connection = getConnection();

            SqlSearch sqlSearch = new SqlSearch();
            int searchId = 123; // Replace with the actual search ID

            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId);
            ResultSet searchResultSet = searchStatement.executeQuery();
            // Process searchResultSet as needed

            PreparedStatement searchColStatement = sqlSearch.getNewSearchColStatement(connection, searchId);
            ResultSet searchColResultSet = searchColStatement.executeQuery();
            // Process searchColResultSet as needed

            // Close the resources appropriately
            searchResultSet.close();
            searchStatement.close();
            searchColResultSet.close();
            searchColStatement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SqlSearch {

    // Replace with your actual database connection details
    private static final String DB_URL = "jdbc:mysql://localhost:3306/your_database";
    private static final String DB_USER = "your_username";
    private static final String DB_PASSWORD = "your_password";

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
    }

    public PreparedStatement getNewSearchStatement(Connection con, int searchId) throws SQLException {
        String tsearchTableName = "tsearch"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public PreparedStatement getNewSearchColStatement(Connection con, int searchId) throws SQLException {
        String tsearchcolTableName = "tsearchcol"; // Replace with the actual table name

        String query = "SELECT * FROM " + tsearchcolTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        SqlSearch sqlSearch = new SqlSearch();
        int searchId = 123; // Replace with the actual search ID

        try (Connection connection = sqlSearch.getConnection()) {
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId);
            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }

            PreparedStatement searchColStatement = sqlSearch.getNewSearchColStatement(connection, searchId);
            try (ResultSet searchColResultSet = searchColStatement.executeQuery()) {
                while (searchColResultSet.next()) {
                    // Process each row in the searchColResultSet
                    // For example: String columnValue = searchColResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


///

public class SqlSearch {

    public PreparedStatement getNewSearchStatement(Connection con, int searchId, boolean useSbm) throws SQLException {
        if (useSbm) {
            String query = "SELECT * FROM t_search WHERE searchId = ?";
            PreparedStatement preparedStatement = con.prepareStatement(query);
            preparedStatement.setInt(1, searchId);
            return preparedStatement;
        } else {
            String query = "SELECT * FROM t_searchcol WHERE searchId = ?";
            PreparedStatement preparedStatement = con.prepareStatement(query);
            preparedStatement.setInt(1, searchId);
            return preparedStatement;
        }
    }

    public static void main(String[] args) {
        int searchId = 123; // Replace with the actual search ID
        boolean useSbm = true; // Change this based on your requirement

        try (Connection connection = getConnection()) {
            SqlSearch sqlSearch = new SqlSearch();
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId, useSbm);

            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

/////

public class SqlSearch {

    public PreparedStatement getNewSearchStatement(Connection con, int searchId, boolean useSbm) throws SQLException {
        String query;
        if (useSbm) {
            Sbm sbm = new Sbm();
            query = sbm.getSearchQuery(searchId);
        } else {
            Sbf sbf = new Sbf();
            query = sbf.getSearchColQuery(searchId);
        }

        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

    public static void main(String[] args) {
        int searchId = 123; // Replace with the actual search ID
        boolean useSbm = true; // Change this based on your requirement

        try (Connection connection = getConnection()) {
            SqlSearch sqlSearch = new SqlSearch();
            PreparedStatement searchStatement = sqlSearch.getNewSearchStatement(connection, searchId, useSbm);

            try (ResultSet searchResultSet = searchStatement.executeQuery()) {
                while (searchResultSet.next()) {
                    // Process each row in the searchResultSet
                    // For example: String columnValue = searchResultSet.getString("columnName");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Replace this with your actual database connection logic
    private static Connection getConnection() throws SQLException {
        // Implement your connection logic here
        return null;
    }
}

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

public class YourClass {

    public static Properties getSSearchStatement(Connection conn, SBM sbmObject, SBFM sbfmObject) throws Exception {
        int searchId = sbmObject.getSearchId();

        if (statementHash.get(searchId + "") != null) {
            return ((Properties) statementHash.get(searchId + ""));
        }

        Properties props = new Properties();

        try {
            // Extract information from sbmObject and sbfmObject
            String tables = sbmObject.getTables();
            List<String> conditions = new ArrayList<>();
            
            String standardCondition = sbmObject.getStandardCondition();
            if (standardCondition != null && !standardCondition.isEmpty()) {
                conditions.add(standardCondition);
            }

            String groupByCondition = sbfmObject.getGroupByCondition();
            if (groupByCondition != null && !groupByCondition.isEmpty()) {
                conditions.add(" group by " + groupByCondition);
            }

            String havingCondition = sbfmObject.getHavingCondition();
            if (havingCondition != null && !havingCondition.isEmpty()) {
                conditions.add(" having " + havingCondition);
            }

            int recCount = sbmObject.getRecordsPerPage();

            // Populate properties based on extracted information
            props.put(SQLSearchStatement.TABLES, tables);

            if (!conditions.isEmpty()) {
                props.put(SQLSearchStatement.CONDITIONS, String.join("", conditions));
            }

            if (recCount > 0) {
                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);
            }

            String columns = sbfmObject.getColumnExpressionsWithAliases();

            if (!columns.isEmpty()) {
                props.put(SQLSearchStatement.COLUMNS, columns);
            } else {
                String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";
                log.error(msg);
                throw new Exception(msg);
            }

            statementHash.put(searchId + "", props);
        } catch (SQLException e) {
            log.error("SQL Exception occurred: " + e.getMessage());
            throw e;
        } finally {
            // Close resources, if needed
        }

        return props;

/////

public static Properties getnewSearchStatement(Connection conn, SBeanMeta s, SBeanFieldMeta t) throws Exception {

        int sid = s.getsid();

        if (statementHash.get(sid + "") != null) {

            return ((Properties) statementHash.get(sid + ""));

        }

        Properties props = new Properties();

        try {
            // Here we extracting information from s and t here

            String tables = s.gettables();

            List<String> conditions = new ArrayList<>();

            String scondition = s.getscondition();

            if (scondition != null && !scondition.isEmpty()) {

                conditions.add("standard_condition_column" );

            }

            String gcondition = s.getgcondition();

            if (gcondition!= null && !gcondition.isEmpty()) {

                conditions.add("group_by_condition_column");
            }

            String hcondition = s.gethcondition();

            if (hcondition != null && !hcondition.isEmpty()) {

                conditions.add(" having_condition_column > 1000 ");

            }


            int rppage = s.getrppage();


            props.put(SQLSearchStatement.TABLES, tables);

            /*
              // hcondition == false
             if (!conditions.isEmpty()) {

                props.put(SQLSearchStatement.CONDITIONS, String.join("", conditions));
            }*/


            //if (recCount > 0) {
               // props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);
         //   }

            String fieldName = t.getfieldName();

            String expression = t.getExpression();

            if (!fieldName.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, fieldName);

            }

            if (!expression.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, expression);

            }

            else
            {

                String text = "Search id" + sid + " is not set up in T_SEARCHCOL";

                log.error(text);

                throw new Exception(text);
            }

            statementHash.put(sid + "", props);

        }

        catch (SQLException z) {

            log.error("SQL Exception occurred: " + z.getMessage());

            throw z;

        }

        return props;
    }

// old

public static Properties getSearchStatement(Connection conn, int searchId) throws SQLException, Exception
    {



        if(statementHash.get(searchId+"") != null)

        {

            return ((Properties)statementHash.get(searchId+""));

        }

        Properties props = new Properties();

        Statement stmt = conn.createStatement();

        // get main statement
        String sql = "select Tables, Standard_Condition, Group_By_Condition, Having_Condition , Records_Per_Page from t_Search where search_id = " + searchId;

        // this sql method is getting tables, standard_condition, group_by_condition, having_condition, records_per_page as output and getting them from t_search with a specific search_id


        ResultSet rs = stmt.executeQuery(sql);

        if (rs.next())

        {
            String tables = rs.getString(1);

            String standardCondition = rs.getString(2);

            String groupByCondition = rs.getString(3);

            String havingCondition = rs.getString(4);

            props.put(SQLSearchStatement.TABLES, tables);

            if (standardCondition != null && !standardCondition.equals(""))
            {
                props.put(SQLSearchStatement.STANDARD_CONDITION, standardCondition);
            }
            if (groupByCondition != null && !groupByCondition.equals(""))

            {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, " group by " + groupByCondition);

            }
            if (havingCondition != null && !havingCondition.equals("")) {

                props.put(SQLSearchStatement.HAVING_CONDITION, " having " + havingCondition);

            }

            int recCount = rs.getInt(5);

            if(recCount > 0) {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT,new Integer(recCount));
            }
        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCH";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);
        }

        rs.close();


        // get columns
        sql = "select Col_Expression, Col_Alias from t_SearchCol where search_id = " + searchId + " order by col_id";

        rs = stmt.executeQuery(sql);

        StringBuffer sb = new StringBuffer();

        while (rs.next()) {

            if (sb.length() > 1) {

                sb.append(", ");

            }

            sb.append(rs.getString(1));

            if (rs.getString(2) != null && !rs.getString(1).equalsIgnoreCase(rs.getString(2))) {

                sb.append(" as ");

                sb.append(rs.getString(2));

            }
        }

        rs.close();

        if (sb.length() > 1) {

            props.put(SQLSearchStatement.COLUMNS, sb.toString());

        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);

        }

        stmt.close();

        statementHash.put(searchId+"" , props);

        return props;
    }

///

 public static Properties getnewSearchStatement(SBeanMeta s, SBeanFieldMeta t) throws Exception
    {

        int sid = s.getsid();

        if (statementHash.get(sid + "") != null)
        {

            return ((Properties) statementHash.get(sid + ""));

        }

        Properties props = new Properties();

        try
        {
            // Here we extracting information from s and t here

            String tables = s.gettables();

            props.put(SQLSearchStatement.TABLES, tables);

            String scondition = s.getscondition();

            if (scondition != null && !scondition.isEmpty()) {


                props.put(SQLSearchStatement.STANDARD_CONDITION, scondition);
            }

            String gcondition = s.getgcondition();

            if (gcondition!= null && !gcondition.isEmpty()) {


                props.put(SQLSearchStatement.GROUP_BY_CONDITION, gcondition);
            }

            String hcondition = s.gethcondition();

            if (hcondition != null && !hcondition.isEmpty()) {


                props.put(SQLSearchStatement.HAVING_CONDITION, hcondition);

            }



            int rppage = s.getrppage(); // rppage is used now

            int recCount = rppage;

            if (recCount > 0) {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);

            }

            else
            {
                String text = "Search id" + sid + " is not set up in T_Search";
                log.error(" Error executing" );
                log.error(text);
                throw new Exception(text);
            }


            // List<SBeanFieldMeta> fields

            /*
              // hcondition == false
             if (!conditions.isEmpty()) {

                props.put(SQLSearchStatement.CONDITIONS, String.join("", conditions));
            }*/


            //if (recCount > 0) {
               // props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, recCount);
         //   }

            String fieldName = t.getfieldName();

            String expression = t.getExpression();

            StringBuffer sb = new StringBuffer();

            // List<SBeanFieldMeta> fields
            
           
            
            if (sb.length() > 1)
            {
                sb.append(", ");
            }

            if (fieldName != null && expression.equalsIgnoreCase(fieldName))
            {
                sb.append(" as ");

                sb.append(fieldName);
            }
            


           /* if (!fieldName.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, fieldName);

            } */



            /*if (!expression.isEmpty())
            {

                props.put(SQLSearchStatement.COLUMNS, expression);

            } */

            else

            {

                String text = "Search id" + sid + " is not set up in T_SEARCHCOL";

                log.error(text);

                throw new Exception(text);
            }

            statementHash.put(sid + "", props);

        }

        catch (SQLException z) {

            log.error("SQL Exception occurred: " + z.getMessage());

            throw z;

        }

        return props;
    }

///////

public static Properties getnewSearchStatement(String fileName) throws Exception
    {


        SBeanMeta s = new SBeanMeta();

        int sid = s.getsid();

        if (statementHash.get(sid + "") != null)
        {

            return ((Properties) statementHash.get(sid + ""));
        }

        Properties props = new Properties();

            // Here we extracting information from s and t here

            String tables = s.gettables();

            props.put(SQLSearchStatement.TABLES, tables);

            String scondition = s.getscondition();

            if (scondition != null && !scondition.isEmpty())

            {

                props.put(SQLSearchStatement.STANDARD_CONDITION, scondition);
            }

            String gcondition = s.getgcondition();

            if (gcondition!= null && !gcondition.isEmpty())
            {


                props.put(SQLSearchStatement.GROUP_BY_CONDITION, gcondition);
            }

            String hcondition = s.gethcondition();

            if (hcondition != null && !hcondition.isEmpty())
            {


                props.put(SQLSearchStatement.HAVING_CONDITION, hcondition);

            }

            int rppage = s.getrppage(); // rppage is used now


            if (rppage > 0)
            {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, rppage);
            }

            else
            {
                String text = "Search id" + sid + " is not set up in T_Search";
                log.error(" Error executing" );
                log.error(text);
                throw new Exception(text);
            }

           List<SBeanFieldMeta> t = s.getFields();

           StringBuffer sb = new StringBuffer();

           for(SBeanFieldMeta field : t)
            {
                String fieldname = field.getfieldName();

                String expression = field.getExpression();

                if (sb.length() > 1)
                {
                    sb.append(", ");
                }

                sb.append(tables);

                if (fieldname != null && expression.equalsIgnoreCase(fieldname))
                {
                    sb.append(" as ");

                    sb.append(fieldname);
                }

            }

           props.put(SQLSearchStatement.COLUMNS, sb.toString());

            try

            {

                String text = "Search id" + sid + " is not set up in T_SEARCHCOL";

                log.error(text);

                throw new Exception(text);
            }
            finally
            {

            statementHash.put(sid + "", props);

            }
        }

        catch (SQLException z)
        {

            log.error("SQL Exception occurred: " + z.getMessage());

            throw z;

        }


///////

public static Properties getSearchStatement(Connection conn, int searchId) throws SQLException, Exception
    {



        if(statementHash.get(searchId+"") != null)

        {

            return ((Properties)statementHash.get(searchId+""));

        }

        Properties props = new Properties();

        Statement stmt = conn.createStatement();

        // get main statement
        String sql = "select Tables, Standard_Condition, Group_By_Condition, Having_Condition , Records_Per_Page from t_Search where search_id = " + searchId;

        // this sql method is getting tables, standard_condition, group_by_condition, having_condition, records_per_page as output and getting them from t_search with a specific search_id


        ResultSet rs = stmt.executeQuery(sql);

        if (rs.next())

        {
            String tables = rs.getString(1);

            String standardCondition = rs.getString(2);

            String groupByCondition = rs.getString(3);

            String havingCondition = rs.getString(4);

            props.put(SQLSearchStatement.TABLES, tables);

            if (standardCondition != null && !standardCondition.equals(""))
            {
                props.put(SQLSearchStatement.STANDARD_CONDITION, standardCondition);
            }
            if (groupByCondition != null && !groupByCondition.equals(""))

            {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, " group by " + groupByCondition);

            }
            if (havingCondition != null && !havingCondition.equals("")) {

                props.put(SQLSearchStatement.HAVING_CONDITION, " having " + havingCondition);

            }

            int recCount = rs.getInt(5);

            if(recCount > 0) {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT,new Integer(recCount));
            }
        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCH";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);
        }

        rs.close();


        // get columns
        sql = "select Col_Expression, Col_Alias from t_SearchCol where search_id = " + searchId + " order by col_id";

        rs = stmt.executeQuery(sql);

        StringBuffer sb = new StringBuffer();

        while (rs.next()) {

            if (sb.length() > 1) {

                sb.append(", ");

            }

            sb.append(rs.getString(1));

            if (rs.getString(2) != null && !rs.getString(1).equalsIgnoreCase(rs.getString(2))) {

                sb.append(" as ");

                sb.append(rs.getString(2));

            }
        }

        rs.close();

        if (sb.length() > 1) {

            props.put(SQLSearchStatement.COLUMNS, sb.toString());

        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);

        }

        stmt.close();

        statementHash.put(searchId+"" , props);

        return props;
    }

////




   public final class SBeanMetaUtil {
    private static final Logger logger = LoggerFactory.getLogger(SBeanMetaUtil.class);
    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;
    private final Function<String, List<SBeanFieldMeta>> reader;
    private final List<String> activeProfiles;
    private Map<String, List<SBeanFieldMeta>> sbeanFieldCache;

    public SBeanMetaUtil(ResourceLoader resourceLoader, Environment environment,
            ObjectMapper objectMapper) {
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
        this.sbeanFieldCache = new HashMap<>();
        String[] profiles = environment.getActiveProfiles();
        if (profiles != null && profiles.length > 0) {
            activeProfiles = Arrays.asList(profiles);
            Collections.reverse(activeProfiles);
            reader = (fileName) -> readMetaFieldsForProfiles(fileName); // active profiles
        } else {
            reader = (fileName) -> readMetaFields(fileName); // if profiles are not active
            activeProfiles = Collections.emptyList();
        }
    }

    // call the two classes SBeanMeta and SBeanFieldsMeta
    // utilize their objects in order to sustain this class

    public List<SBeanFieldMeta> getSBeanFieldsMeta(String fileName) { // getSBeanFieldsMeta --- this is getting the SBeanFieldsMeta from the call
        if (!sbeanFieldCache.containsKey(fileName)) {
            logger.info(
                "{} not present in cache for file : {} and active profiles : {}. Will do resource lookup.",
                SBeanFieldMeta.class.getSimpleName(), fileName, activeProfiles);
            sbeanFieldCache.put(fileName, reader.apply(fileName));
        }
        return sbeanFieldCache.get(fileName);
    }

    private List<SBeanFieldMeta> readMetaFields(String fileName) { // readMetaFields -- this is reading MetaFields
        Resource resource = loadResourceFromClasspath(
            SBEAN_META_DIR + PATH_SEPARATOR + fileName + JSON_EXTENSION);
        return ordered(readMetaFields(resource));
    }

    private Resource loadResourceFromClasspath(String path) {  // loadResourceFromClasspath --  this is loading the resource from the classpath
        return resourceLoader.getResource("classpath:" + path);
    }

    private List<SBeanFieldMeta> readMetaFieldsForProfiles(String fileName) {  // readMetaFieldsForProfiles -- this is reading the metadata fields with and without considering profiles
        Set<SBeanFieldMeta> fields = new HashSet<>();
        fields.addAll(readMetaFields(fileName));
        for (String profile : activeProfiles) {
            Resource resource = loadResourceFromClasspath(SBEAN_META_DIR + PATH_SEPARATOR + profile
                + PATH_SEPARATOR + fileName + JSON_EXTENSION);
            fields.addAll(readMetaFields(resource));
        }
        return ordered(fields);
    }

    private Set<SBeanFieldMeta> readMetaFields(Resource resource) {  // readMetaFields -- this is reading the metaFields and returns them in an ordered list
        if (resource.exists()) {
            try (InputStream inputStream = resource.getInputStream()) {
                SBeanMeta beanMeta = objectMapper.readValue(inputStream, SBeanMeta.class);
                if (beanMeta != null && beanMeta.fields != null && !beanMeta.fields.isEmpty()) {
                    return beanMeta.fields.stream().map(field -> getHyphenatedMetaFields(field))
                        .flatMap(Set::stream).collect(toSet());
                }
            } catch (IOException e) {
                logger.error(e.getMessage(), e);
            }
        }
        return Collections.emptySet();
    }

    private List<SBeanFieldMeta> ordered(Set<SBeanFieldMeta> fieldMetas) {  // ordered -- this returns the SBeanFieldMeta into an ordered list of SBeanFieldMeta
        return new ArrayList<>(fieldMetas).stream().sorted(comparator())
            .collect(Collectors.toList());
    }

    private Comparator<SBeanFieldMeta> comparator() {  // comparator
        return comparing(SBeanFieldMeta::getDisplayOrder, nullsLast(Integer::compareTo))
            .thenComparing(SBeanFieldMeta::getFieldName, nullsLast(String::compareTo));
    }

    private Set<SBeanFieldMeta> getHyphenatedMetaFields(SBeanFieldMeta field) {  // getHyphenatedMetaFields
        if (field.nestedFields == null || field.nestedFields.isEmpty()) {
            return new HashSet<>(Arrays.asList(field));
        } else {
            String parentName = field.fieldName;
            return field.nestedFields.stream().map(f -> {
                f.fieldName = parentName + "-" + f.fieldName;
                return getHyphenatedMetaFields(f);
            }).flatMap(Set::stream).collect(toSet());
        }
    }

}

////

public List<SBeanFieldMeta> nestedFields;

public final class SBeanMetaUtil {
    private static final Logger logger = LoggerFactory.getLogger(SBeanMetaUtil.class);
    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;
    private final Function<String, List<SBeanFieldMeta>> reader;
    private final List<String> activeProfiles;
    private Map<String, List<SBeanFieldMeta>> sbeanFieldCache;

    public SBeanMetaUtil(ResourceLoader resourceLoader, Environment environment,
            ObjectMapper objectMapper) {
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
        this.sbeanFieldCache = new HashMap<>();
        String[] profiles = environment.getActiveProfiles();
        if (profiles != null && profiles.length > 0) {
            activeProfiles = Arrays.asList(profiles);
            Collections.reverse(activeProfiles); // this will reverse the list
            reader = (fileName) -> readMetaFieldsForProfiles(fileName); // active profiles json files
        } else {
            reader = (fileName) -> readMetaFields(fileName); // if profiles are not active
            activeProfiles = Collections.emptyList();
        }
    }

    // call the two classes SBeanMeta and SBeanFieldsMeta
    // utilize their objects in order to sustain this class

    public List<SBeanFieldMeta> getSBeanFieldsMeta(String fileName) { // getSBeanFieldsMeta --- this is getting the SBeanFieldsMeta from the call
        if (!sbeanFieldCache.containsKey(fileName)) {
            logger.info(
                "{} not present in cache for file : {} and active profiles : {}. Will do resource lookup.",
            SBeanFieldMeta.class.getSimpleName(), fileName, activeProfiles);

            sbeanFieldCache.put(fileName, reader.apply(fileName));

            List<SBeanFieldMeta> sbeanFields = reader.apply(filename);

            List<SBeanMeta> SBeanMeta = SBeanMeta.parseFields(sbeanFields);

            MetaDataObject metadata = new MetaDataObject(sbeanFields, SBeanMeta);

            sbeanFieldcache.put(filename, metadataObject);
        }
        return sbeanFieldCache.get(fileName);
    }

    private List<SBeanFieldMeta> readMetaFields(String fileName) { // readMetaFields -- this is reading MetaFields
        Resource resource = loadResourceFromClasspath(
            SBEAN_META_DIR + PATH_SEPARATOR + fileName + JSON_EXTENSION);
        return ordered(readMetaFields(resource));
    }

    private Resource loadResourceFromClasspath(String path) {  // loadResourceFromClasspath --  this is loading the resource from the classpath
        return resourceLoader.getResource("classpath:" + path);
    }

    private List<SBeanFieldMeta> readMetaFieldsForProfiles(String fileName) {  // readMetaFieldsForProfiles -- this is reading the metadata fields with and without considering profiles
        Set<SBeanFieldMeta> fields = new HashSet<>();
        fields.addAll(readMetaFields(fileName));
        for (String profile : activeProfiles) {
            Resource resource = loadResourceFromClasspath(SBEAN_META_DIR + PATH_SEPARATOR + profile
                + PATH_SEPARATOR + fileName + JSON_EXTENSION);
            fields.addAll(readMetaFields(resource));
        }
        return ordered(fields);
    }

    private Set<SBeanFieldMeta> readMetaFields(Resource resource) {  // readMetaFields -- this is reading the metaFields and returns them in an ordered list
        if (resource.exists()) {
            try (InputStream inputStream = resource.getInputStream()) {
                SBeanMeta beanMeta = objectMapper.readValue(inputStream, SBeanMeta.class);
                if (beanMeta != null && beanMeta.fields != null && !beanMeta.fields.isEmpty()) {
                    return beanMeta.fields.stream().map(field -> getHyphenatedMetaFields(field))
                        .flatMap(Set::stream).collect(toSet());
                }
            } catch (IOException e) {
                logger.error(e.getMessage(), e);
            }
        }
        return Collections.emptySet();
    }

    private List<SBeanFieldMeta> ordered(Set<SBeanFieldMeta> fieldMetas) {  // ordered -- this returns the SBeanFieldMeta into an ordered list of SBeanFieldMeta
        return new ArrayList<>(fieldMetas).stream().sorted(comparator())
            .collect(Collectors.toList());
    }

    private Comparator<SBeanFieldMeta> comparator() {  // comparator
        return comparing(SBeanFieldMeta::getDisplayOrder, nullsLast(Integer::compareTo))
            .thenComparing(SBeanFieldMeta::getFieldName, nullsLast(String::compareTo));
    }

    private Set<SBeanFieldMeta> getHyphenatedMetaFields(SBeanFieldMeta field) {  // getHyphenatedMetaFields
        if (field.nestedFields == null || field.nestedFields.isEmpty()) {
            return new HashSet<>(Arrays.asList(field));
        } else {
            String parentName = field.fieldName;
            return field.nestedFields.stream().map(f -> {
                f.fieldName = parentName + "-" + f.fieldName;
                return getHyphenatedMetaFields(f);
            }).flatMap(Set::stream).collect(toSet());
        }
    }

}
// this is the end of SBeanMetaUtil.java


////

 public Integer depoId; // depository

  public Integer sid; // search_id column

  public Integer cid; // column_id column

  public Integer key; // col is_key column

  public Integer req; // required column

  public Integer sort; // sortable column

  public String format; // ui format column

  public Integer filter; // input filter column

  public String expression; //col exp column

  public String fieldName; //col alias column

  public boolean hidden; //visible column

  public String label; //disp name column

  public String type; //disp format column

  public Integer displayOrder; //disp order column

  //public SBeanFieldQueryMeta query;

  public String source;

  public boolean summarizer;

  public List<SBeanFieldMeta> nestedFields;

 // public List<Formatter> formatters;

  public List<Long> accounts;

  // columns that these have to be in line with are search_id, col_id, col_expression, col_alias, disp_name, disp_format, is_key, required

  // visible, sortable, disp_order, ui_format, input_filter

  // these are from t_search and t_searchcol respectively

 // public SBeanFieldMeta() //
//  {

 // }

  public SBeanFieldMeta(String fieldName, String label)
  {
      this.fieldName = fieldName; // this is for col_alias

      this.label = label; // this is for display name
  }

  /**
   * @return the accounts
   */
  public List<Long> getAccounts()
  {
      return accounts; // this will return the accounts
  }

  /**
   * @param accounts the accounts to set
   */

  public Integer getDepoId()
  {
      return depoId; // this will return depoId
  }

  public Integer sid()
  {
      return sid; // this will return search_id
  }

  public Integer cid()
  {
      return cid; // this will return cid
  }
  /**
   * @param depoID the depoID to set
   */
  public Integer key()
  {
      return key; // this will return key
  }
  public Integer req()
  {
      return req; // this will return req
  }

  public Integer sort()
  {
      return sort; // this will return sort
  }

  public Integer filter()
  {
      return filter; // this will return filter
  }

  public void setAccounts(List<Long> accounts)
  {
      this.accounts = accounts; // this will create an instance called accounts
  }

  /**
   * @return the depoID
   */

  public void setDepoId(Integer depoId)
  {
      this.depoId = depoId; // this will create an instance called depoId
  }

  /**
   * @return the label
   */

  public String getExpression()
  {
      return expression; // this represents col_expression
  }

  public String getFieldName()
  {
      return fieldName; // this wil return the field name
  }

  public String getLabel()
  {
      return label; // this will return the label
  }

  /**
   * @return the query
   */
 // public SBeanFieldQueryMeta getQuery()
 // {
 //     return query; // this will return the query
 // }

  /**
   * @return the source
   */
  public String getSource()
  {
      return source; // this will return the source
  }

  /**
   * @return the type
   */
  public String getType()
  {
      return type; // this will return the disp_format column as output
  }

  /**
   * @return the summarizer
   */
  public boolean isSummarizer()
  {
      return summarizer; // this will return the summarizer
  }

  /**
   * @param label
   *            the label to set
   */

  public void setLabel(String label)
  {
      this.label = label; // this will create an instance caled label
  }

  /**
   * @param query
   *            the query to set
   */
 // public void setQuery(SBeanFieldQueryMeta query)
  //{
  //    this.query = query; // this creates an instance query
  //}

  /**
   * @param source
   *            the source to set
   */
  public void setSource(String source)
  {
      this.source = source; // this creates an instance source
  }

  /**
   * @param summarizer
   *            the summarizer to set
   */
  public void setSummarizer(boolean summarizer)
{
      this.summarizer = summarizer; // this creates an instance summarizer
  }

  /**
   * @param type
   *            the type to set
   */
  public void setType(String type)
  {
      this.type = type; // this creates an instance of type called type
  }

  /**
   * @return the expression
   */


  /**
   * @param expression the expression to set
   */
  public void setExpression(String expression)
  {
      this.expression = expression; // this represents the expression instance of a classs
  }



  public void setFieldName(String fieldName)
  {
      this.fieldName = fieldName; // this represents the field name instance of a class
  }

  public boolean isHidden()
  {
      return hidden; // this returns hidden which is of boolean type
  }

  public void setHidden(boolean hidden)
  {
      this.hidden = hidden; // this creates an instance of hidden
  }

  public List<SBeanFieldMeta> getNestedFields()
  {
      return nestedFields; // this returns nestesFields which is in a list
  }

  public void setNestedFields(List<SBeanFieldMeta> nestedFields)
  {
      this.nestedFields = nestedFields; // this represents the nested fields instance of a class
  }

  //public List<Formatter> getFormatters()
  // {
  //    return formatters; // this returns formatters as output
  // }

  // public void setFormatters(List<Formatter> formatters)
  // {
  //    this.formatters = formatters; // this represents the formatters instance of a class
  // }

  @Override
  public int hashCode()
  {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((fieldName == null) ? 0 : fieldName.hashCode());
      return result; // this will return the result as output
  }

  @Override
  public boolean equals(Object obj) // this boolean object here is equals. This will only return true or false
  {
      if (this == obj) { // if the value of this is equal to that of obj
          return true;
      }
      if (obj == null) { // if the value of obj is equal to that if null or it doesn't have any values
          return false;
      }
      if (getClass() != obj.getClass()) { // if the getClass object and obj.getClass objects have the same value
          return false; // this will return false as output
      }
      SBeanFieldMeta other = (SBeanFieldMeta) obj;
      if (fieldName == null) { // if the fieldName here has null value or nothing at all
          if (other.fieldName != null) {
              return false; // this will give false as the output on console
          }
      } else if (!fieldName.equals(other.fieldName)) { // if whatever is not inside the value of other.fieldname is nothing
          return false; // this will give false as the output
      }
      return true;
  }

  public Integer getDisplayOrder()
  {
      return displayOrder; // this will return the displayOrder as output
  }

  public void setDisplayOrder(Integer displayOrder)
  {
      this.displayOrder = displayOrder; // this represents the displayOrder instance of a class
  }



}
