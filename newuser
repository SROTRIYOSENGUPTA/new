/**
 * Copyright Stonewain Systems Inc.

 */
// this is the beginning of SBeanMetaUtil.java
package com.stonewain.spring.util;

import static com.stonewain.common.constants.Constants.JSON_EXTENSION;
import static com.stonewain.common.constants.Constants.PATH_SEPARATOR;
import static com.stonewain.common.constants.Constants.SBEAN_META_DIR;
import static java.util.Comparator.comparing;
import static java.util.Comparator.nullsLast;
import static java.util.stream.Collectors.toSet;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.scache.model.SBeanFieldMeta;
import com.scache.model.SBeanMeta;

/**
 * @author Sukhpal Singh
 */


// take in a search id -> search and parse for the json file using the search id and rename the file that it is searching with the search id name


public final class SBeanMetaUtil {
    private static final Logger logger = LoggerFactory.getLogger(SBeanMetaUtil.class);
    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;
    private final Function<String, SBeanMeta> reader;
    private final List<String> activeProfiles;
    private int searchId;

    public Map<String, SBeanMeta> sbeanFieldCache;

    public SBeanMetaUtil(ResourceLoader resourceLoader, Environment environment, ObjectMapper objectMapper) {
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
        this.sbeanFieldCache = new HashMap<>();
        String[] profiles = environment.getActiveProfiles();
        if (profiles != null && profiles.length > 0) {
            activeProfiles = Arrays.asList(profiles);
            Collections.reverse(activeProfiles);
            reader = (fileName) -> readMetaFieldsForProfiles(fileName);
        } else {
            reader = (fileName) -> readMetaFields(fileName);
            activeProfiles = Collections.emptyList();
        }
    }
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }

    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }

    public SBeanMeta getSBeanFieldsMeta(String fileName) {
        if (!sbeanFieldCache.containsKey(fileName)) {
            logger.info(
                    "{} not present in cache for file : {} and active profiles : {}. Will do resource lookup.",
                    SBeanMeta.class.getSimpleName(), fileName, activeProfiles);

            SBeanMeta sBeanMeta = reader.apply(fileName);
            sbeanFieldCache.put(fileName, sBeanMeta);
        }
        return sbeanFieldCache.get(fileName);
    }

    public SBeanMeta getSBeanMeta(String fileName) {
        if (!sbeanFieldCache.containsKey(fileName)) {
            logger.info(
                    "{} not present in cache for file : {} and active profiles : {}. Will do resource lookup.",
                    SBeanMeta.class.getSimpleName(), fileName, activeProfiles);

            SBeanMeta sBeanMeta = reader.apply(fileName);
            sbeanFieldCache.put(fileName, sBeanMeta);
        }
        return sbeanFieldCache.get(fileName);
    }

    public SBeanMeta groupwithprefix(String prefix) {
        SBeanMeta combinedSBeanMeta = new SBeanMeta();
        List<String> matchingFileNames = new ArrayList<>();

        for (String fileName : sbeanFieldCache.keySet()) {
            if (fileName.startsWith(prefix)) {
                matchingFileNames.add(fileName);
            }
        }
        matchingFileNames.sort(Comparator.comparingInt(this::extractNumericValue));

        for (String fileName : matchingFileNames) {
            SBeanMeta sBeanMeta = sbeanFieldCache.get(fileName);
            combinedSBeanMeta.combine(sBeanMeta);
        }

        return combinedSBeanMeta;
    }

    private int extractNumericValue(String fileName) {
        String numericPart = fileName.replaceAll("[^0-9]", "");
        return Integer.parseInt(numericPart);
    }

    private SBeanMeta readMetaFields(String fileName) {
        Resource resource = loadResourceFromClasspath(SBEAN_META_DIR + PATH_SEPARATOR + fileName + JSON_EXTENSION);
        return ordered(readMetaFields(resource));
    }

    private Resource loadResourceFromClasspath(String path) {
        return resourceLoader.getResource("classpath:" + path);
    }

    private SBeanMeta readMetaFieldsForProfiles(String fileName) {
        SBeanMeta fields = new SBeanMeta();
        fields.combine(readMetaFields(fileName));

        for (String profile : activeProfiles) {

            Resource resource = loadResourceFromClasspath(SBEAN_META_DIR + PATH_SEPARATOR + profile + PATH_SEPARATOR + fileName + JSON_EXTENSION);
            fields.combine(readMetaFields(resource));

        }
        return fields;
    }

    private SBeanMeta readMetaFields(Resource resource) {
        SBeanMeta beanMeta = new SBeanMeta();
        if (resource.exists()) {
            try (InputStream inputStream = resource.getInputStream()) {
                beanMeta = objectMapper.readValue(inputStream, SBeanMeta.class);
                if (beanMeta != null && beanMeta.getFields() != null && !beanMeta.getFields().isEmpty()) {


                }
            } catch (IOException e) {
                logger.error(e.getMessage(), e);
            }
        }
        return beanMeta;
    }

    private SBeanMeta ordered(SBeanMeta beanMeta) {

        return beanMeta.ordered();
    }
}
