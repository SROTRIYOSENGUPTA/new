/*
 * Created on Jun 11, 2005


 */

// this is the beginning of SQLSearchStatement.java


package com.oceanview.sql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Hashtable;
import java.util.List;
import java.util.Properties;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.oceanview.dto.SearchInfo;
import com.oceanview.scachetestnew.SBeanMeta;
import com.scache.model.SBeanFieldMeta;
import com.stonewain.spring.util.SBeanMetaUtil;

/**
 * @author Adithya/Louie
 *
 */
public class SQLSearchStatement {
    public List<SBeanFieldMeta> fields;
    private static Logger log = Logger.getLogger(SQLSearchStatement.class.getName());


    final public static String TABLES                = "T";
    final public static String COLUMNS                = "C";
    final public static String STANDARD_CONDITION    = "SC";
    final public static String GROUP_BY_CONDITION    = "GB";
    final public static String HAVING_CONDITION        = "HC";
    final public static String DEFAULT_RECORD_COUNT = "RC";

    private static Hashtable statementHash = new Hashtable();
    private static SBeanMetaUtil sBeanMetaUtil;
    private static SBeanMeta sBeanMeta;

    public static String buildSearchSQL(Connection conn, int searchId, String customTableString,
            String preCondition, String postCondition, String orderBy, String sortOrder,
            SearchInfo colInfo) throws SQLException, Exception {
        Properties props = null;
        SBeanMetaUtil sBeanMetaUtil = null;

        try
        {
            props = getnewSearchStatement(conn, searchId, sBeanMetaUtil, sBeanMeta);
        } catch (Exception e) {
            props = getSearchStatement(conn, searchId);
        }

        return buildSearchSQL(props, customTableString, preCondition, postCondition, orderBy,
                 sortOrder, colInfo, null);
    }

    public static String buildSearchSQL(Connection conn, int searchId, String preCondition,
            String postCondition, String orderBy, String sortOrder, SearchInfo colInfo,
            String havingCondition) throws SQLException, Exception {
        Properties props = null;
        SBeanMetaUtil sBeanMetaUtil = null;
        try
        {
            props = getnewSearchStatement(conn, searchId, sBeanMetaUtil, sBeanMeta);
        } catch (Exception e) {
            props = getSearchStatement(conn, searchId);
        }
        return buildSearchSQL(props, null, preCondition, postCondition, orderBy, sortOrder, colInfo,
                havingCondition);
    }

    public static String buildSearchSQL(Connection conn, int searchId, String preCondition,
            String postCondition, String orderBy, SearchInfo colInfo)
                    throws SQLException, Exception {
        Properties props = null;
        SBeanMetaUtil sBeanMetaUtil = null;
        try
        {
            props = getnewSearchStatement(conn, searchId, sBeanMetaUtil, sBeanMeta);
        } catch (Exception e) {
            props = getSearchStatement(conn, searchId);
        }

        return buildSearchSQL(props, null, preCondition, postCondition, orderBy, null, colInfo,
                null);
    }

    public static Properties getSearchStatement(Connection conn, int searchId) throws SQLException, Exception
    {



        if(statementHash.get(searchId+"") != null)

        {

            return ((Properties)statementHash.get(searchId+""));

        }

        Properties props = new Properties();

        Statement stmt = conn.createStatement();


        String sql = "select Tables, Standard_Condition, Group_By_Condition, Having_Condition , Records_Per_Page from t_Search where search_id = " + searchId;

        ResultSet rs = stmt.executeQuery(sql);

        if (rs.next())

        {
            String tables = rs.getString(1);

            String standardCondition = rs.getString(2);

            String groupByCondition = rs.getString(3);

            String havingCondition = rs.getString(4);

            props.put(SQLSearchStatement.TABLES, tables);

            if (standardCondition != null && !standardCondition.equals(""))
            {
                props.put(SQLSearchStatement.STANDARD_CONDITION, standardCondition);
            }
            if (groupByCondition != null && !groupByCondition.equals(""))

            {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, " group by " + groupByCondition);

            }
            if (havingCondition != null && !havingCondition.equals("")) {

                props.put(SQLSearchStatement.HAVING_CONDITION, " having " + havingCondition);

            }

            int recCount = rs.getInt(5);

            if(recCount > 0) {

                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT,new Integer(recCount));
            }
        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCH";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);
        }

        rs.close();


        sql = "select Col_Expression, Col_Alias from t_SearchCol where search_id = " + searchId + " order by col_id";

        rs = stmt.executeQuery(sql);

        StringBuffer sb = new StringBuffer();

        while (rs.next()) {

            if (sb.length() > 1) {

                sb.append(", ");

            }

            sb.append(rs.getString(1));

            if (rs.getString(2) != null && !rs.getString(1).equalsIgnoreCase(rs.getString(2))) {

                sb.append(" as ");

                sb.append(rs.getString(2));

            }
        }

        rs.close();

        if (sb.length() > 1) {

            props.put(SQLSearchStatement.COLUMNS, sb.toString());

        }

        else

        {
            String msg = "Search id " + searchId + " is not set up in T_SEARCHCOL";

            log.error("Error executing:" + sql);

            log.error(msg);

            throw new Exception(msg);

        }

        stmt.close();

        statementHash.put(searchId+"" , props);

        return props;
    }

    @SuppressWarnings("unused")


// utilize properties of resourceLoader, environment and objectMapper from SBeanMetaUtil
  //  resourceLoader loads a resource, environment utilizes the environment while objectMapper maps the objects

   /* public static Properties getnewSearchStatement(Connection conn, int searchId, SBeanMetaUtil sBeanMetaUtil) throws Exception {
        Properties props = new Properties();

        SBeanMeta s = new SBeanMeta();

        if (statementHash.get(searchId + "") != null) {

            return ((Properties) statementHash.get(searchId + ""));
        }

        List<SBeanFieldMeta> fields = sBeanMetaUtil.getSBeanMeta("sample.json");

        // populate sbeanmeta object so that it replaces the sbeanfieldmeta

        if (s != null) {

            String tables = "";

            String scondition = "";

            String gcondition = "";

            String hcondition = "";

            int rppage = 0;

            props.put(SQLSearchStatement.TABLES, tables);

            if (scondition != null && !scondition.isEmpty()) {
                props.put(SQLSearchStatement.STANDARD_CONDITION, scondition);
            }

            if (gcondition != null && !gcondition.isEmpty()) {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, gcondition);
            }

            if (hcondition != null && !hcondition.isEmpty()) {
                props.put(SQLSearchStatement.HAVING_CONDITION, hcondition);
            }

            if (rppage > 0) {
                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, String.valueOf(rppage));
            }
        }
        else {

            System.out.println("No data is available in the fields list.");
            String text = "Search id " + searchId + " is not set up properly.";
            log.error("Error executing");
            log.error(text);
            throw new Exception(text);
        } // this is the end of the method for s

        if (fields != null && !fields.isEmpty()) {

            String tables = "";
            String scondition = "";
            String gcondition = "";
            String hcondition = "";
            int rppage = 0;

            props.put(SQLSearchStatement.TABLES, tables);

            if (scondition != null && !scondition.isEmpty()) {
                props.put(SQLSearchStatement.STANDARD_CONDITION, scondition);
            }

            if (gcondition != null && !gcondition.isEmpty()) {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, gcondition);
            }

            if (hcondition != null && !hcondition.isEmpty()) {
                props.put(SQLSearchStatement.HAVING_CONDITION, hcondition);
            }

            if (rppage > 0) {
                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, String.valueOf(rppage));
            }
        } else {
            System.out.println("No data is available in the fields list.");
            String text = "Search id " + searchId + " is not set up properly.";
            log.error("Error executing");
            log.error(text);
            throw new Exception(text);
        }

        // Assuming you have some logic to generate the COLUMNS property based on fields

        statementHash.put(searchId + "", props);

        return props;
    }

    public static void main(String[] args)
    {
        int searchId = 123;

        try {
            Properties result = SQLSearchStatement.getnewSearchStatement(null, searchId, new SBeanMetaUtil(null, null, null));
            System.out.println("The output of this code will be: " + result);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
    */
   public static Properties getnewSearchStatement(Connection conn, int searchId, SBeanMetaUtil sBeanMetaUtil, SBeanMeta sBeanMeta)
  throws Exception {
        Properties props = new Properties();

        if (statementHash.get(searchId + "") != null) {
            return ((Properties) statementHash.get(searchId + ""));
        }

        List<SBeanFieldMeta> fields = sBeanMetaUtil.getSBeanMeta("sample.json");

        if (fields != null && !fields.isEmpty()) {

            String tables = "";
            String scondition = "";
            String gcondition = "";
            String hcondition = "";
            int rppage = 0;

            props.put(SQLSearchStatement.TABLES, tables);

            if (scondition != null && !scondition.isEmpty()) {
                props.put(SQLSearchStatement.STANDARD_CONDITION, scondition);
            }

            if (gcondition != null && !gcondition.isEmpty()) {
                props.put(SQLSearchStatement.GROUP_BY_CONDITION, gcondition);
            }

            if (hcondition != null && !hcondition.isEmpty()) {
                props.put(SQLSearchStatement.HAVING_CONDITION, hcondition);
            }

            if (rppage > 0) {
                props.put(SQLSearchStatement.DEFAULT_RECORD_COUNT, String.valueOf(rppage));
            }

        } else {
            System.out.println("No data is available in the fields list.");
            String text = "Search id " + searchId + " is not set up properly.";
            log.error("Error executing");
            log.error(text);
            throw new Exception(text);
        }

        if (fields != null && !fields.isEmpty()) {

            sBeanMeta.tables();
            sBeanMeta.scondition();
            sBeanMeta.gcondition();

            statementHash.put(searchId + "", props);
        } else {
            System.out.println("No data is available in the fields list.");
            String text = "Search id " + searchId + " is not set up properly.";
            log.error("Error executing");
            log.error(text);
            throw new Exception(text);
        }

        return props;
    }

    public static void main(String[]args) {

        SBeanMeta sBeanMeta = new SBeanMeta();
        SBeanMetaUtil sBeanMetaUtil = new SBeanMetaUtil(null, null, null);
        Connection conn = null;
        int searchId = 123;

        try {

            Properties result = getnewSearchStatement(conn , searchId, sBeanMetaUtil, sBeanMeta);
            System.out.println("Result: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    public PreparedStatement getNewSearchColStatement(Connection con, int searchId) throws SQLException
        {
        String tsearchcolTableName = "tsearchcol";

        String query = "SELECT * FROM " + tsearchcolTableName + " WHERE searchId = ?";
        PreparedStatement preparedStatement = con.prepareStatement(query);
        preparedStatement.setInt(1, searchId);
        return preparedStatement;
    }

        public static String buildSearchSQL(Properties props, String customTableString,
            String preCondition, String postCondition, String orderBy, String sortOrder,
            SearchInfo colInfo, String havingCondition) {
        StringBuffer sb = new StringBuffer();
        sb.append("select ");

        if (colInfo != null && colInfo.getColName() != null && colInfo.getColName().length > 0) {
            String[] colNames = colInfo.getColName();
            int i = 0;
            for (i = 0; i < colNames.length - 1; i++) {
                sb.append(colNames[i] + ", ");
            }

            sb.append(colNames[i] + " ");
        } else {
            sb.append(" * ");
        }

        sb.append(" from (select ");

        String columnStr = props.getProperty(SQLSearchStatement.COLUMNS);
        if (columnStr == null) {
            return null;
        }
        sb.append(columnStr);
        sb.append(" from ");
        if (customTableString != null) {
            sb.append(customTableString + " ");
        }

        sb.append(props.getProperty(SQLSearchStatement.TABLES));

        if (props.containsKey(SQLSearchStatement.STANDARD_CONDITION) || preCondition != null) {
            sb.append(" where ");
        }

        if (props.containsKey(SQLSearchStatement.STANDARD_CONDITION) && preCondition != null) {
            sb.append(props.getProperty(SQLSearchStatement.STANDARD_CONDITION));
            sb.append(" and (");
            sb.append(preCondition);
            sb.append(")");
        } else if (props.containsKey(SQLSearchStatement.STANDARD_CONDITION) && preCondition == null) {
            sb.append(props.getProperty(SQLSearchStatement.STANDARD_CONDITION));
        } else if (!props.containsKey(SQLSearchStatement.STANDARD_CONDITION)
                && preCondition != null) {
            sb.append(preCondition);
        }

        if (props.containsKey(SQLSearchStatement.GROUP_BY_CONDITION)) {
            sb.append(props.getProperty(SQLSearchStatement.GROUP_BY_CONDITION));
        }

        if (props.containsKey(SQLSearchStatement.HAVING_CONDITION)) {
            sb.append(props.getProperty(SQLSearchStatement.HAVING_CONDITION));
        } else if (StringUtils.isNotEmpty(havingCondition)) {
            String havCond = havingCondition.toUpperCase().replaceFirst("AND", " ");
            sb.append(" having " + havCond);
        }
        sb.append(") A ");

        if (postCondition != null) {
            sb.append("where ");
            sb.append(postCondition);
        }

        if (orderBy != null) {
            sb.append(" order by ");
            sb.append(orderBy);

            if (sortOrder != null) {
                sb.append(" " + sortOrder);
            }
        }

        return sb.toString();
    }

        public static String newbuildSearchSQL(List<SBeanFieldMeta> fields, String customTableString,
                String preCondition, String postCondition, String orderBy, String sortOrder,
                SearchInfo colInfo, String havingCondition)
        {

            StringBuilder sb = new StringBuilder();

            sb.append("select ");

            if (colInfo != null && colInfo.getColName() != null && colInfo.getColName().length > 0)
            {

                String[] colNames = colInfo.getColName();

                int a = 0;

                for (a = 0; a< colNames.length - 1; a++) {

                    sb.append(colNames[a]).append(", ");
                }
                sb.append(colNames[a]).append(" ");

            }

            else
            {


                String columnStr = SBeanMetaUtil.generateColumns(fields);

                sb.append(columnStr);
            }

            sb.append(" from (select ");


            String filterCondition = SBeanMetaUtil.generateFilterConditions(fields);

            if (!filterCondition.isEmpty()) {

                if (sb.indexOf(" where ") == -1) {

                    sb.append(" where ");

                }

                else
                {

                    sb.append(" and ");
                }

                sb.append(filterCondition);
            }

            String classpath = System.getProperty("java.class.path");
            System.out.println(classpath);



            return sb.toString();


        }

}



// this is the end of SQLSearchStatement.java

/////

SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/C:/Users/SSengupta/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/C:/Users/SSengupta/git/OceanviewAPP/OceanviewEAR/EarContent/APP-INF/lib/slf4j-log4j12-1.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/C:/Users/SSengupta/git/OceanviewAPP/OceanviewEAR/EarContent/APP-INF/lib/slf4j-simple-1.1.0-RC1.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/C:/Users/SSengupta/git/OceanviewAPP/OceanviewEAR/EarContent/APP-INF/lib/spire-standalone.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]
Exception in thread "main" java.lang.NullPointerException
	at com.stonewain.spring.util.SBeanMetaUtil.<init>(SBeanMetaUtil.java:59)
	at com.oceanview.sql.SQLSearchStatement.main(SQLSearchStatement.java:402)


